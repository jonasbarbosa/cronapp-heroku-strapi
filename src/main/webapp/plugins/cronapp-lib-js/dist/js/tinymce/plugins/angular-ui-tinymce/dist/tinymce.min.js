/**
 * Binds a TinyMCE widget to <textarea> elements.
 */
angular.module('ui.tinymce', [])
.value('uiTinymceConfig', {})
.directive('uiTinymce', ['$rootScope', '$compile', '$timeout', '$window', '$sce', 'uiTinymceConfig', 'uiTinymceService','$translate', function($rootScope, $compile, $timeout, $window, $sce, uiTinymceConfig, uiTinymceService, $translate) {
  uiTinymceConfig = uiTinymceConfig || {};
  if (uiTinymceConfig.baseUrl) {
    tinymce.baseURL = uiTinymceConfig.baseUrl;
  }

  return {
    require: ['ngModel', '^?form'],
    priority: 599,
    link: function(scope, element, attrs, ctrls) {
      if (!$window.tinymce) {
        return;
      }

      var ngModel = ctrls[0],
          form = ctrls[1] || null;

      var ngAttrs = {};

      for (var prop in attrs) {
        if (attrs.hasOwnProperty(prop)) {
          ngAttrs[prop] = attrs[prop];
        }
      }

      var expression, options = {
            debounce: true
          }, tinyInstance,
          updateView = function(editor) {
            var content = editor.getContent({format: options.format}).trim();
            content = $sce.trustAsHtml(content);

            ngModel.$setViewValue(content);
            if (!$rootScope.$$phase) {
              scope.$digest();
            }
          };

      function toggleDisable(disabled) {
        if (disabled) {
          ensureInstance();

          if (tinyInstance) {
            tinyInstance.getBody().setAttribute('contenteditable', false);
          }
        } else {
          ensureInstance();

          if (tinyInstance && !tinyInstance.settings.readonly && tinyInstance.getDoc()) {
            tinyInstance.getBody().setAttribute('contenteditable', true);
          }
        }
      }

      // fetch a unique ID from the service
      // var uniqueId = uiTinymceService.getUniqueId();
      // attrs.$set('id', uniqueId);

      expression = {};

      // angular.extend(expression, scope.$eval(attrs.uiTinymce));
      angular.extend(expression, JSON.parse(unescape(attrs.uiTinymce)));

      //Debounce update and save action
      var debouncedUpdate = (function(debouncedUpdateDelay) {
        var debouncedUpdateTimer;
        return function(ed) {
          $timeout.cancel(debouncedUpdateTimer);
          debouncedUpdateTimer = $timeout(function() {
            return (function(ed) {
              if (ed.isDirty()) {
                ed.save();
                updateView(ed);
              }
            })(ed);
          }, debouncedUpdateDelay);
        };
      })(400);

      var setupOptions = {
        // Update model when calling setContent
        // (such as from the source editor popup)
        setup: function(ed) {
          ed.on('init', function() {
            ngModel.$render();
            ngModel.$setPristine();
            ngModel.$setUntouched();
            if (form) {
              form.$setPristine();
            }
            if (ngAttrs.ngCronInit) {
              scope.$eval(ngAttrs.ngCronInit);
            }
          });

          // Update model when:
          // - a button has been clicked [ExecCommand]
          // - the editor content has been modified [change]
          // - the node has changed [NodeChange]
          // - an object has been resized (table, image) [ObjectResized]
          ed.on('ExecCommand change NodeChange ObjectResized', function() {
            if (!options.debounce) {
              ed.save();
              updateView(ed);
              return;
            }
            debouncedUpdate(ed);
          });

          ed.on('blur', function() {
            element[0].blur();
            ngModel.$setTouched();
            if (!$rootScope.$$phase) {
              scope.$digest();
            }
            if (ngAttrs.ngCronBlur) {
              scope.$eval(ngAttrs.ngCronBlur);
            }
          });

          ed.on('remove', function() {
            element.remove();
            if (ngAttrs.ngRemove) {
              scope.$eval(ngAttrs.ngRemove);
            }
          });

          if (ngAttrs.ngNodeChange) { ed.on('NodeChange', function () { scope.$eval(ngAttrs.ngNodeChange); }); }
          if (ngAttrs.ngCronChange) { ed.on('change', function () { scope.$eval(ngAttrs.ngCronChange); }); }
          if (ngAttrs.ngExecCommand) { ed.on('ExecCommand', function () { scope.$eval(ngAttrs.ngExecCommand); }); }
          if (ngAttrs.ngCronClick) { ed.on('click', function () { scope.$eval(ngAttrs.ngCronClick); }); }
          if (ngAttrs.ngCronDblclick) { ed.on('dblclick', function () { scope.$eval(ngAttrs.ngCronDblclick); }); }
          if (ngAttrs.ngCronMouseDown) { ed.on('mousedown', function () { scope.$eval(ngAttrs.ngCronMouseDown); }); }
          if (ngAttrs.ngCronMouseUp) { e.on('mouseup', function () { scope.$eval(ngAttrs.ngCronMouseUp); }); }
          if (ngAttrs.ngCronMouseMove) { ed.on('mousemove', function () { scope.$eval(ngAttrs.ngCronMouseMove); }); }
          if (ngAttrs.ngCronMouseOver) { ed.on('mouseover', function () { scope.$eval(ngAttrs.ngCronMouseOver); }); }
          if (ngAttrs.ngCronMouseEnter) { ed.on('mouseenter', function () { scope.$eval(ngAttrs.ngCronMouseEnter); }); }
          if (ngAttrs.ngCronMouseLeave) { ed.on('mouseleave', function () { scope.$eval(ngAttrs.ngCronMouseLeave); }); }
          if (ngAttrs.ngCronKeydown) { ed.on('keydown', function () { scope.$eval(ngAttrs.ngCronKeydown); }); }
          if (ngAttrs.ngCronKeyup) { e.on('keyup', function () { scope.$eval(ngAttrs.ngCronKeyup); }); }
          if (ngAttrs.ngCronKeypress) { ed.on('keypress', function () { scope.$eval(ngAttrs.ngCronKeypress); }); }
          if (ngAttrs.ngContextMenu) { ed.on('contextmenu', function () { scope.$eval(ngAttrs.ngContextMenu); }); }
          if (ngAttrs.ngCronPaste) { ed.on('paste', function () { scope.$eval(ngAttrs.ngCronPaste); }); }
          if (ngAttrs.ngCronFocus) { ed.on('focus', function () { scope.$eval(ngAttrs.ngCronFocus); }); }
          if (ngAttrs.ngBeforeSetContent) { ed.on('BeforeSetContent', function () { scope.$eval(ngAttrs.ngBeforeSetContent); }); }
          if (ngAttrs.ngSetContent) { ed.on('SetContent', function () { scope.$eval(ngAttrs.ngSetContent); }); }
          if (ngAttrs.ngGetContent) { ed.on('GetContent', function () { scope.$eval(ngAttrs.ngGetContent); }); }
          if (ngAttrs.ngPreProcess) { ed.on('PreProcess', function () { scope.$eval(ngAttrs.ngPreProcess); }); }
          if (ngAttrs.ngPostProcess) { ed.on('PostProcess', function () { scope.$eval(ngAttrs.ngPostProcess); }); }
          if (ngAttrs.ngCronUndo) { ed.on('Undo', function () { scope.$eval(ngAttrs.ngCronUndo); }); }
          if (ngAttrs.ngCronRedo) { ed.on('Redo', function () { scope.$eval(ngAttrs.ngCronRedo); }); }
          if (ngAttrs.ngCronDirty) { ed.on('Dirty', function () { scope.$eval(ngAttrs.ngCronDirty); }); }
          if (ngAttrs.ngPastePreProcess) { ed.on('PastePreProcess', function () { scope.$eval(ngAttrs.ngPastePreProcess); }); }
          if (ngAttrs.ngPastePostProcess) { ed.on('PastePostProcess', function () { scope.$eval(ngAttrs.ngPastePostProcess); }); }
          if (ngAttrs.ngAddEditor) { ed.on('AddEditor', function () { scope.$eval(ngAttrs.ngAddEditor); }); }
          if (ngAttrs.ngRemoveEditor) { ed.on('RemoveEditor', function () { scope.$eval(ngAttrs.ngRemoveEditor); }); }

          if (uiTinymceConfig.setup) {
            uiTinymceConfig.setup(ed, {
              updateView: updateView
            });
          }

          if (expression.setup) {
            expression.setup(ed, {
              updateView: updateView
            });
          }
        },
        format: expression.format || 'html',
        selector: '#' + attrs.id
      };
      // extend options with initial uiTinymceConfig and
      // options from directive attribute value
      angular.extend(options, uiTinymceConfig, expression, setupOptions);
      // Wrapped in $timeout due to $tinymce:refresh implementation, requires
      // element to be present in DOM before instantiating editor when
      // re-rendering directive
      $timeout(function() {
        if (options.baseURL){
          tinymce.baseURL = options.baseURL;
        }

        ngModel.$formatters.unshift(function(modelValue) {
          return modelValue ? $sce.trustAsHtml(modelValue) : '';
        });

        if (!options.language) {
          if ($translate.use() == 'pt_br')
            options.language = 'pt_BR';
          else
            options.language = 'en_CA';
        }
        var maybeInitPromise = tinymce.init(options);
        var removeBy = setInterval(function() {
          $('.mce-branding.mce-widget.mce-label.mce-flow-layout-item.mce-last').remove();
        }, 100);
        if(maybeInitPromise && typeof maybeInitPromise.then === 'function') {
          maybeInitPromise.then(function() {
            toggleDisable(scope.$eval(attrs.ngDisabled));
          });
        } else {
          toggleDisable(scope.$eval(attrs.ngDisabled));
        }
      });

      ngModel.$parsers.unshift(function(viewValue) {
        return viewValue ? $sce.getTrustedHtml(viewValue) : '';
      });

      ngModel.$render = function() {
        ensureInstance();

        var viewValue = ngModel.$viewValue ?
            $sce.getTrustedHtml(ngModel.$viewValue) : '';

        // instance.getDoc() check is a guard against null value
        // when destruction & recreation of instances happen
        if (tinyInstance &&
            tinyInstance.getDoc()
        ) {
          tinyInstance.setContent(viewValue);
          // Triggering change event due to TinyMCE not firing event &
          // becoming out of sync for change callbacks
          tinyInstance.fire('change');
        }
      };

      attrs.$observe('disabled', toggleDisable);

      // This block is because of TinyMCE not playing well with removal and
      // recreation of instances, requiring instances to have different
      // selectors in order to render new instances properly
      var unbindEventListener = scope.$on('$tinymce:refresh', function(e, id) {
        var eid = attrs.id;
        if (angular.isUndefined(id) || id === eid) {
          var parentElement = element.parent();
          var clonedElement = element.clone();
          clonedElement.removeAttr('id');
          clonedElement.removeAttr('style');
          clonedElement.removeAttr('aria-hidden');
          tinymce.execCommand('mceRemoveEditor', false, eid);
          parentElement.append($compile(clonedElement)(scope));
          unbindEventListener();
        }
      });

      scope.$on('$destroy', function() {
        ensureInstance();

        if (tinyInstance) {
          tinyInstance.remove();
          tinyInstance = null;
        }
      });

      function ensureInstance() {
        if (!tinyInstance) {
          tinyInstance = tinymce.get(attrs.id);
        }
      }
    }
  };
}])
.service('uiTinymceService', [
  /**
   * A service is used to create unique ID's, this prevents duplicate ID's if there are multiple editors on screen.
   */
  function() {
    var UITinymceService = function() {
      var ID_ATTR = 'ui-tinymce';
      // uniqueId keeps track of the latest assigned ID
      var uniqueId = 0;
      // getUniqueId returns a unique ID
      var getUniqueId = function() {
        uniqueId ++;
        return ID_ATTR + '-' + uniqueId;
      };
      // return the function as a public method of the service
      return {
        getUniqueId: getUniqueId
      };
    };
    // return a new instance of the service
    return new UITinymceService();
  }
]);